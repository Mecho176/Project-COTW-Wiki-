import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ammoPath = path.resolve(__dirname, '../src/data/ammunition.js');

function parseCaliberAndType(name) {
  if (!name || typeof name !== 'string') return { caliber: null, type: null };
  const original = name.trim();
  // Handle common patterns
  // 1) weight-based arrows/bolts: starts with e.g. "300 gr." or "300 gr"
  const grMatch = original.match(/^(\d+(?:\.\d+)?)\s*gr\.?/i);
  if (grMatch) {
    const caliber = `${grMatch[1]} gr.`;
    const type = original.slice(grMatch[0].length).trim() || 'Regular';
    return { caliber, type };
  }
  // 2) gauge like '12 GA', '10 GA'
  const gaMatch = original.match(/^(\d+)\s*(GA|ga|Ga)\b/);
  if (gaMatch) {
    const caliber = `${gaMatch[1]} GA`;
    const type = original.slice(gaMatch[0].length).trim();
    return { caliber, type };
  }
  // 3) leading dot calibers like '.308', '.223', '.243', or named calibers like '7.62x39mm'
  const firstTok = original.split(/\s+/)[0];
  // if first token contains digits and dots or x or starts with a dot
  if (/^[\.\d].*/.test(firstTok) || /x/.test(firstTok)) {
    const caliber = firstTok;
    const type = original.slice(firstTok.length).trim();
    return { caliber, type };
  }
  // 4) calibers that are two tokens like '.45 Colt' or '45 Colt'
  const twoToken = original.split(/\s+/).slice(0,2).join(' ');
  if (/^(\.?\d+(?:\.\d+)?\s+Colt|\d+\s+Colt)/i.test(twoToken)) {
    const parts = original.split(/\s+/);
    const caliber = `${parts[0]} ${parts[1]}`;
    const type = original.split(/\s+/).slice(2).join(' ');
    return { caliber, type };
  }
  // Fallback: take first token as caliber, rest as type
  const toks = original.split(/\s+/);
  const caliber = toks[0];
  const type = toks.slice(1).join(' ') || null;
  return { caliber, type };
}

(async function main(){
  try {
    const imported = await import(`file://${ammoPath}`);
    const ammo = imported.default || imported.ammo || imported;
    if (!Array.isArray(ammo)) {
      console.error('ammo import did not return an array');
      process.exit(1);
    }

    let changed = false;
    for (const a of ammo) {
      const name = a.name || a.id || '';
      const parsed = parseCaliberAndType(name);
      if (!a.caliber && parsed.caliber) {
        a.caliber = parsed.caliber;
        changed = true;
      }
      if (!a.type && parsed.type) {
        a.type = parsed.type;
        changed = true;
      }
    }

    if (!changed) {
      console.log('No changes required; ammo already has caliber/type fields.');
      process.exit(0);
    }

    // Write back file as a JS module
    const out = `// Auto-generated ammunition file (normalized)\n// Generated by tools/normalizeAmmo.mjs\n\nconst ammunition = ${JSON.stringify(ammo, null, 2)};\n\nexport const ammo = ammunition;\nexport default ammunition;\n`;

    fs.writeFileSync(ammoPath, out, 'utf8');
    console.log('Wrote normalized ammunition to', ammoPath);
  } catch (err) {
    console.error('normalize failed', err);
    process.exit(2);
  }
})();
