import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const root = path.resolve(__dirname, '..');
const weaponsPath = path.join(root, 'src', 'data', 'weapons.js');
const ammoPath = path.join(root, 'src', 'data', 'ammunition.js');
const outMapPath = path.join(root, 'src', 'data', 'weaponAmmoMap.js');

function normalizeText(s) {
  return s
    .toLowerCase()
    .replace(/\b(bullet|bullets|round|rounds|cartridge|cartridges|mag)\b/gi, ' ')
    .replace(/[^a-z0-9]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function stripTags(str) {
  return str.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ').trim();
}

async function fetchWeaponPage(slug) {
  const url = `https://thehuntercotw.fandom.com/wiki/${encodeURIComponent(slug)}`;
  try {
    const res = await fetch(url);
    if (!res.ok) return null;
    const text = await res.text();
    return text;
  } catch (e) {
    return null;
  }
}

async function fetchPageLinks(slug) {
  const api = `https://thehuntercotw.fandom.com/api.php?action=parse&page=${encodeURIComponent(slug)}&prop=links&format=json`;
  try {
    const res = await fetch(api);
    if (!res.ok) return [];
    const json = await res.json();
    const links = (json.parse && json.parse.links) ? json.parse.links.map(l => l['*']) : [];
    return links;
  } catch (e) {
    return [];
  }
}

function parseAmmunitionFromHtml(html) {
  if (!html) return [];
  const sectionRe = /<span class="mw-headline"[^>]*>(Ammunition|Ammo)<\/span>[\s\S]*?(<ul>[\s\S]*?<\/ul>|<p>[\s\S]*?<\/p>)/i;
  const m = html.match(sectionRe);
  if (!m) return [];
  const block = m[0];
  const ulMatch = block.match(/<ul>[\s\S]*?<\/ul>/i);
  const listHtml = ulMatch ? ulMatch[0] : block;
  const liRe = /<li[^>]*>([\s\S]*?)<\/li>/gi;
  const items = [];
  let mm;
  while ((mm = liRe.exec(listHtml))) {
    const txt = stripTags(mm[1]);
    if (txt) items.push(txt);
  }
  if (items.length === 0) {
    const pMatch = block.match(/<p[^>]*>([\s\S]*?)<\/p>/i);
    if (pMatch) {
      const raw = stripTags(pMatch[1]);
      raw.split(/[;,]/).map(s => s.trim()).filter(Boolean).forEach(i=>items.push(i));
    }
  }
  return items;
}

async function main() {
  console.log('Reading weapons and ammunition...');
  const { pathToFileURL } = await import('url');
  const weaponsModule = await import(pathToFileURL(weaponsPath).href);
  const weaponList = weaponsModule.weapons || [];
  const weaponIds = weaponList.map(w => w.id).filter(Boolean);
  const ammoText = fs.readFileSync(ammoPath, 'utf8');
  // parse ammunition.js for id/name pairs
  const ammoArray = [];
  const re = /id:\s*"([^"]+)"[\s\S]*?name:\s*"([^"]+)"/g;
  let m;
  while ((m = re.exec(ammoText))) {
    ammoArray.push({ id: m[1], name: m[2] });
  }
  const ammoMap = new Map();
  for (const a of ammoArray) {
    ammoMap.set(normalizeText(a.name), a.id);
    ammoMap.set(normalizeText(a.id), a.id);
  }

  const resultMap = {};
  let processed = 0;
  for (const id of weaponIds) {
    processed++;
    process.stdout.write(`Processing ${processed}/${weaponIds.length}: ${id}... `);
    const html = await fetchWeaponPage(id);
    const items = parseAmmunitionFromHtml(html);
    const linkedAmmo = [];
    // use the MediaWiki API to list links on the page (more reliable)
    const pageLinks = await fetchPageLinks(id);
    for (const linkName of pageLinks) {
      const slug = linkName.replace(/ /g, '_');
      if (ammoArray.find(x => x.id === slug)) linkedAmmo.push(slug);
      const norm = normalizeText(linkName);
      if (ammoMap.has(norm)) linkedAmmo.push(ammoMap.get(norm));
    }
    const combined = items.concat(linkedAmmo);
    const matchedAmmoIds = [];
    for (const it of combined) {
      const key = normalizeText(it);
      if (ammoMap.has(key)) matchedAmmoIds.push(ammoMap.get(key));
      else {
        for (const [k, v] of ammoMap.entries()) {
          if (key.includes(k) || k.includes(key)) {
            matchedAmmoIds.push(v);
            break;
          }
        }
      }
    }
    const uniq = Array.from(new Set(matchedAmmoIds));
    resultMap[id] = uniq;
    console.log(`found ${uniq.length}`);
    await new Promise(r => setTimeout(r, 300));
  }

  const header = `// Auto-generated mapping: weapon page slug -> array of compatible ammunition labels\n// Generated by tools/crawlWeaponPages.js\n\nconst weaponAmmoMap = ${JSON.stringify(resultMap, null, 2)};\n\nexport default weaponAmmoMap;\n`;
  fs.writeFileSync(outMapPath, header, 'utf8');
  console.log('Wrote', outMapPath);

  console.log('Running sync script to update ammunition.js');
  const { spawn } = await import('child_process');
  await new Promise((resolve, reject) => {
    const p = spawn(process.execPath, [path.join(root,'tools','syncRelatedIds.js')], { stdio: 'inherit' });
    p.on('exit', code => code === 0 ? resolve() : reject(new Error('sync script failed')));
  });
  console.log('Sync complete.');
}

main().catch(err => { console.error(err); process.exit(1); });
